@book{arora2009computational,
  title={Computational complexity: a modern approach},
  author={Arora, Sanjeev and Barak, Boaz},
  year={2009},
  publisher={Cambridge University Press}
}

@misc{blanc2024samplecomplexitysmoothboosting,
      title={The Sample Complexity of Smooth Boosting and the Tightness of the Hardcore Theorem}, 
      author={Guy Blanc and Alexandre Hayderi and Caleb Koch and Li-Yang Tan},
      year={2024},
      eprint={2409.11597},
      archivePrefix={arXiv},
      primaryClass={cs.CC},
      url={https://arxiv.org/abs/2409.11597}, 
}

@inbook{doi:10.1137/1.9781611977554.ch151,
author = {Soheil Behnezhad and Mohammad Roghani and Aviad Rubinstein and Amin Saberi},
title = {Beating Greedy Matching in Sublinear Time},
booktitle = {Proceedings of the 2023 Annual ACM-SIAM Symposium on Discrete Algorithms (SODA)},
chapter = {},
pages = {3900-3945},
doi = {10.1137/1.9781611977554.ch151},
URL = {https://epubs.siam.org/doi/abs/10.1137/1.9781611977554.ch151},
eprint = {https://epubs.siam.org/doi/pdf/10.1137/1.9781611977554.ch151},
    abstract = { We study sublinear time algorithms for estimating the size of maximum matching in graphs. Our main result is a (½ + Ω(1))-approximation algorithm which can be implemented in O(n1+ε) time, where n is the number of vertices and the constant ε > 0 can be made arbitrarily small. The best known lower bound for the problem is Ω(n), which holds for any constant approximation. Existing algorithms either obtain the greedy bound of ½-approximation [Behnezhad FOCS'21], or require some assumption on the maximum degree to run in o(n2)-time [Yoshida, Yamamoto, and Ito STOC'09]. We improve over these by designing a less “adaptive” augmentation algorithm for maximum matching that might be of independent interest. }
}

@article{doi:10.1073/pnas.1421853112,
author = {Ross Anderson  and Itai Ashlagi  and David Gamarnik  and Alvin E. Roth },
title = {Finding long chains in kidney exchange using the traveling salesman problem},
journal = {Proceedings of the National Academy of Sciences},
volume = {112},
number = {3},
pages = {663-668},
year = {2015},
doi = {10.1073/pnas.1421853112},
URL = {https://www.pnas.org/doi/abs/10.1073/pnas.1421853112},
eprint = {https://www.pnas.org/doi/pdf/10.1073/pnas.1421853112},
abstract = {There are currently more than 100,000 patients on the waiting list in the United States for a kidney transplant from a deceased donor. To address this shortage, kidney exchange programs allow patients with living incompatible donors to exchange donors through cycles and chains initiated by altruistic nondirected donors. To determine which exchanges will take place, kidney exchange programs use algorithms for maximizing the number of transplants under constraints about the size of feasible exchanges. This problem is NP-hard, and algorithms previously used were unable to optimize when chains could be long. We developed two algorithms that use integer programming to solve this problem, one of which is inspired by the traveling salesman, that together can find optimal solutions in practice. As of May 2014 there were more than 100,000 patients on the waiting list for a kidney transplant from a deceased donor. Although the preferred treatment is a kidney transplant, every year there are fewer donors than new patients, so the wait for a transplant continues to grow. To address this shortage, kidney paired donation (KPD) programs allow patients with living but biologically incompatible donors to exchange donors through cycles or chains initiated by altruistic (nondirected) donors, thereby increasing the supply of kidneys in the system. In many KPD programs a centralized algorithm determines which exchanges will take place to maximize the total number of transplants performed. This optimization problem has proven challenging both in theory, because it is NP-hard, and in practice, because the algorithms previously used were unable to optimally search over all long chains. We give two new algorithms that use integer programming to optimally solve this problem, one of which is inspired by the techniques used to solve the traveling salesman problem. These algorithms provide the tools needed to find optimal solutions in practice.}}
